PREFIX asam: <http://ontology.asam.net/ontologies/Domain#>
## finto posto dove teniamo tutti gli id per smartedge
PREFIX se-data: <http://uc2.smartedge.com/ontologies/smartedge/data#>
PREFIX geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX sosa: <http://www.w3.org/ns/sosa#>

## 0 used as unkown
## 6 should be delivery vehicle (not in asam ontology)
## 7 should be short truck (not in asam ontology)
## 8 should be long truck (not in asam ontology)
#set($vehicleTypeMap = { "0": "TrafficPartecipant",
                         "1": "Pedestrian",
                         "2": "Bicycle",
                         "3": "Motorcycle",
                         "4": "Car",
                         "6": "Truck",
                         "7": "Truck",
                         "8": "Truck" })

#set ($sensors = $reader.getDataframe('{
        "iterator": "$",
        "paths": { "source": "source",
                   "status": "status",
                   "timestamp": "tstamp",
                   "nobjects": "nobjects" }}'))

#set ($observations = $reader.getDataframe('{
          "iterator": "$.objects[*]",
          "paths": { "id": "id",
                     "latitude": "lat",
                     "longitude": "lon",
                     "speed": "speed",
                     "bearing": "bearing",
                     "quality": "quality",
                     "length": "length",
                     "type": "class",
                     "lane": "lane",
                     "acceleration": "acceleration",
                     "last_updated": "last_updated" }}'))

## solo un sensore per file
#set ($sensor = $sensors[0])
#set ($sensorSubject = "se-data:Sensor-" + $sensor.source)
## definizione del sensore e di quali sono le cose che possono essere osservabili dal sensore rispetto ad un FeatureOfInterest, cioè il veicolo identificato, in generale cosa gli interessa.
$sensorSubject rdf:type sosa:Sensor ;
  sosa:Observes se-data:ObservableProperty-speed ;
  sosa:Observes se-data:ObservableProperty-angle ;
  sosa:Observes se-data:ObservableProperty-length .  

se-data:ObservableProperty-speed rdf:type sosa:ObservableProperty ;
  rdf:label "speed"^^xsd:string .
se-data:ObservableProperty-angle rdf:type sosa:ObservableProperty ;
  rdf:label "angle"^^xsd:string .
se-data:ObservableProperty-length rdf:type sosa:ObservableProperty ;
  rdf:label "length"^^xsd:string .

#foreach ($o in $observations)
## sto assumendo che le misurazioni vengano sempre fatte, mai fallisca nel fare proprio la misurazione
## teoricamente andrebbe fatto il check che la misurazione ci sia
se-data:Observation-$o.id-$sensor.source-$sensor.timestamp-speed rdf:type sosa:Observation ;
  sosa:madeBySensor $sensorSubject ;
  sosa:observedProperty se-data:ObservableProperty-speed .
se-data:Observation-$o.id-$sensor.source-$sensor.timestamp-length rdf:type sosa:Observation ;
  sosa:madeBySensor $sensorSubject ;
  sosa:observedProperty se-data:ObservableProperty-length .
se-data:Observation-$o.id-$sensor.source-$sensor.timestamp-angle rdf:type sosa:Observation ;
  sosa:madeBySensor $sensorSubject ;
  sosa:observedProperty se-data:ObservableProperty-angle .

se-data:LengthQuantity-$o.id rdf:type asam:LengthQuantity ;
  rdf:type sosa:Result ;
  asam:hasValue "$o.length"^^xsd:float ;
  sosa:resultTime "$sensor.timestamp"^^xsd:dateTime .

se-data:SpeedQuantity-$o.id rdf:type asam:SpeedQuantity ;
  rdf:type sosa:Result ;
  asam:hasValue "$o.speed"^^xsd:float ;
    sosa:resultTime "$sensor.timestamp"^^xsd:dateTime .

## qua da fare conversione da bearing ad angle
se-data:AngleQuantity-$o.id rdf:type asam:AngleQuantity ;
  rdf:type sosa:Result ;
  asam:hasValue "$o.bearing"^^xsd:float ;
    sosa:resultTime "$sensor.timestamp"^^xsd:dateTime .

## cosa il sensore sta osservando, cioè il veicolo 
se-data:$o.id rdf:type sosa:FeatureOfInterest ;
  rdf:type asam:$vehicleTypeMap.get($o.type) ;
  sosa:isFeatureOfInterestOf se-data:Observation-$o.id-$sensor.source-$sensor.timestamp-speed ;
  sosa:isFeatureOfInterestOf se-data:Observation-$o.id-$sensor.source-$sensor.timestamp-angle ;
  sosa:isFeatureOfInterestOf se-data:Observation-$o.id-$sensor.source-$sensor.timestamp-length ;
  asam:hasLength se-data:LengthQuantity-$o.id ;
  asam:hasSpeed se-data:SpeedQuantity-$o.id ;
  asam:hasAngle se-data:AngleQuantity-$o.id ;
  geo:lat "$o.latitude"^^xsd:float ;
  geo:long "$o.longitude"^^xsd:float .

## per identificare la lane come facciamo?
## in teoria servirebbe identificare la strada e poi dire questa e' la lane 0 di strada x
#end